# Трекер задач

Вам предстоит написать бэкенд для такого трекера. В итоге должна получиться программа, отвечающая за формирование модели данных для этой страницы:

<img src="docs/img.png"/>

----

## Типы задач

Простейший кирпичик трекера — ***задача*** (англ. ***task***). У неё есть следующие свойства:  
1. ***Название***, кратко описывающее суть задачи (например, «Переезд»).
2. ***Описание***, в котором раскрываются детали.
3. ***Уникальный идентификационный номер задачи***, по которому её можно будет найти.
4. ***Статус***, отображающий её прогресс. Вы будете выделять следующие этапы жизни задачи, используя `enum`:
   1. `NEW` — задача только создана, но к её выполнению ещё не приступили.
   2. `IN_PROGRESS` — над задачей ведётся работа.
   3. `DONE` — задача выполнена.  

Иногда для выполнения какой-нибудь масштабной задачи её лучше разбить на ***подзадачи*** (англ. ***subtask***). Большая задача, которая делится на подзадачи, называется ***эпиком*** (англ. ***epic***).  

Подытожим. В системе задачи могут быть трёх типов: обычные задачи, эпики и подзадачи. Для них должны выполняться следующие условия:  
 - Для каждой подзадачи известно, в рамках какого эпика она выполняется. 
 - Каждый эпик знает, какие подзадачи в него входят.
 - Завершение всех подзадач эпика считается завершением эпика.

*Для эталонного решения мы выбрали создание публичного не абстрактного класса `main.java.ru.yandex.practicum.tasktracker.model.Task`, который представляет отдельно стоящую задачу. Его данные наследуют подклассы `main.java.ru.yandex.practicum.tasktracker.model.Subtask` и `main.java.ru.yandex.practicum.tasktracker.model.Epic`.  
В нашем задании класс `main.java.ru.yandex.practicum.tasktracker.model.Task` можно использовать сам по себе, не делая его абстрактным. Для подклассов `main.java.ru.yandex.practicum.tasktracker.model.Subtask` и `main.java.ru.yandex.practicum.tasktracker.model.Epic` наследуем сразу имплементацию, поскольку нам понадобится такое расширение функциональности, которое совместимо с базовым классом и не отличается от него по поведению.*

----

## Идентификатор задачи

В трекере у каждого типа задач есть идентификатор. Это целое число, уникальное для всех типов задач. По нему находят, обновляют, удаляют задачи. При создании задачи менеджер присваивает ей новый идентификатор.  

*Для генерации идентификаторов можно использовать числовое поле-счётчик внутри класса main.java.ru.yandex.practicum.tasktracker.service.InMemoryTaskManager, увеличивая его на 1, когда нужно получить новое значение.*

Также советуем применить знания о методах `equals()` и `hashCode()`, чтобы реализовать идентификацию задачи по её `id`.  При этом две задачи с одинаковым `id` должны выглядеть для менеджера как одна и та же.

----
 ## Менеджер

Кроме классов для описания задач, вам нужно реализовать класс для объекта-менеджера. Он будет запускаться на старте программы и управлять всеми задачами. В нём должны быть реализованы следующие функции:  
1. Возможность хранить задачи всех типов. Для этого вам нужно выбрать подходящую коллекцию.
2. Методы для каждого из типа задач(Задача/Эпик/Подзадача):  
   1. Получение списка всех задач.
   2. Удаление всех задач.
   3. Получение по идентификатору.
   4. Создание. Сам объект должен передаваться в качестве параметра.
   5. Обновление. Новая версия объекта с верным идентификатором передаётся в виде параметра.
   6. Удаление по идентификатору.
3. Дополнительные методы:
   1. Получение списка всех подзадач определённого эпика.
4. Управление статусами осуществляется по следующему правилу:
   1. Менеджер сам не выбирает статус для задачи. Информация о нём приходит менеджеру вместе с информацией о самой задаче. По этим данным в одних случаях он будет сохранять статус, в других будет рассчитывать.
   2. Для эпиков:
      - если у эпика нет подзадач или все они имеют статус `NEW`, то статус должен быть `NEW`.
      - если все подзадачи имеют статус `DONE`, то и эпик считается завершённым — со статусом `DONE`.
      - во всех остальных случаях статус должен быть `IN_PROGRESS`
      
----

## Testing

Создайте в классе `Main` метод `static void main(String[] args)` и внутри него:  
 - Создайте две задачи, а также эпик с двумя подзадачами и эпик с одной подзадачей.
 - Распечатайте списки эпиков, задач и подзадач через `System.out.println(..)`.
 - Измените статусы созданных объектов, распечатайте их. Проверьте, что статус задачи и подзадачи сохранился, а статус эпика рассчитался по статусам подзадач.
 - И, наконец, попробуйте удалить одну из задач и один из эпиков.  
  Воспользуйтесь дебаггером среды разработки, чтобы понять логику работы программы и отладить её.

----

## Подсказки

#### Хранение задач
Для хранения задач вам нужно:
1) получать задачи по идентификатору;
2) выводить списки задач разных типов.  
Один из способов организовать такое хранение — это присвоить соответствие между идентификатором и задачей при помощи `HashMap`. Поскольку идентификатор не может повторяться, такой подход позволит быстро получать задачу.  
   
Чтобы получать разные типы задач, вы можете создать три структуры `HashMap`: по одной на каждый из видов задач.


#### Обновление данных
При обновлении данных можете считать, что на вход подаётся новый объект, который должен полностью заменить старый. К примеру, метод для обновления эпика может принимать эпик в качестве входных данных `public void updateTask(main.java.ru.yandex.practicum.tasktracker.model.Task task)`. Если вы храните эпики в `HashMap`, где ключами являются идентификаторы, то обновление — это запись нового эпика `tasks.put(task.getId(), task))`.


#### Обновление статуса задачи
Фраза «информация приходит вместе с информацией по задаче» означает, что не существует отдельного метода, который занимался бы только обновлением статуса задачи. Вместо этого статус задачи обновляется вместе с полным обновлением задачи.


#### Обновление эпиков
Из описания задачи видно, что эпик не управляет своим статусом самостоятельно. Это значит:
1) Пользователь не должен иметь возможности поменять статус эпика самостоятельно.
2) Когда меняется статус любой подзадачи в эпике, вам необходимо проверить, что статус эпика изменится соответствующим образом. При этом изменение статуса эпика может и не произойти, если в нём, к примеру, всё ещё есть незакрытые задачи.
